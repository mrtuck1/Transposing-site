'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _line = require('./line');

var _line2 = _interopRequireDefault(_line);

var _tag = require('./tag');

var _tag2 = _interopRequireDefault(_tag);

var _paragraph = require('./paragraph');

var _paragraph2 = _interopRequireDefault(_paragraph);

var _utilities = require('../utilities');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents a song in a chord sheet. Currently a chord sheet can only have one song.
 */
var Song = function () {
  function Song() {
    var metaData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Song);

    /**
     * The {@link Line} items of which the song consists
     * @member
     * @type {Array<Line>}
     */
    this.lines = [];

    /**
     * The {@link Paragraph} items of which the song consists
     * @member
     * @type {Array<Line>}
     */
    this.paragraphs = [];

    this.currentLine = null;
    this.currentParagraph = null;
    this.assignMetaData(metaData);
  }

  _createClass(Song, [{
    key: 'assignMetaData',
    value: function assignMetaData(metaData) {
      var _this = this;

      this.rawMetaData = {};

      Object.keys(metaData).forEach(function (key) {
        _this.setMetaData(key, metaData[key]);
      });
    }

    /**
     * Returns the song lines, skipping the leading empty lines (empty as in not rendering any content). This is useful
     * if you want to skip the "header lines": the lines that only contain meta data.
     * @returns {Array<Line>} The song body lines
     */

  }, {
    key: 'chords',
    value: function chords(chr) {
      this.currentLine.chords(chr);
    }
  }, {
    key: 'lyrics',
    value: function lyrics(chr) {
      this.ensureLine();
      this.currentLine.lyrics(chr);
    }
  }, {
    key: 'addLine',
    value: function addLine() {
      this.ensureParagraph();
      this.flushLine();
      this.currentLine = (0, _utilities.pushNew)(this.lines, _line2.default);
      return this.currentLine;
    }
  }, {
    key: 'setCurrentLineType',
    value: function setCurrentLineType(type) {
      if (this.currentLine) {
        this.currentLine.type = type;
      }
    }
  }, {
    key: 'flushLine',
    value: function flushLine() {
      if (this.currentLine !== null) {
        if (this.currentLine.isEmpty()) {
          this.addParagraph();
        } else if (this.currentLine.hasRenderableItems()) {
          this.currentParagraph.addLine(this.currentLine);
        }
      }
    }
  }, {
    key: 'finish',
    value: function finish() {
      this.flushLine();
    }
  }, {
    key: 'addChordLyricsPair',
    value: function addChordLyricsPair() {
      this.ensureLine();
      return this.currentLine.addChordLyricsPair();
    }
  }, {
    key: 'ensureLine',
    value: function ensureLine() {
      if (this.currentLine === null) {
        this.addLine();
      }
    }
  }, {
    key: 'addParagraph',
    value: function addParagraph() {
      this.currentParagraph = (0, _utilities.pushNew)(this.paragraphs, _paragraph2.default);
      return this.currentParagraph;
    }
  }, {
    key: 'ensureParagraph',
    value: function ensureParagraph() {
      if (this.currentParagraph === null) {
        this.addParagraph();
      }
    }
  }, {
    key: 'addTag',
    value: function addTag(tagContents) {
      var tag = _tag2.default.parse(tagContents);

      if (tag.isMetaTag()) {
        this.setMetaData(tag.name, tag.value);
      }

      this.ensureLine();
      this.currentLine.addTag(tag);

      return tag;
    }

    /**
     * Returns a deep clone of the song
     * @returns {Song} The cloned song
     */

  }, {
    key: 'clone',
    value: function clone() {
      var clonedSong = new Song();
      clonedSong.lines = this.lines.map(function (line) {
        return line.clone();
      });
      clonedSong.rawMetaData = _extends({}, this.rawMetaData);
      return clonedSong;
    }
  }, {
    key: 'setMetaData',
    value: function setMetaData(name, value) {
      this.optimizedMetaData = null;

      if (!(name in this.rawMetaData)) {
        this.rawMetaData[name] = new Set();
      }

      this.rawMetaData[name].add(value);
    }

    /**
     * Returns the song metadata. When there is only one value for an entry, the value is a string. Else, the value is
     * an array containing all unique values for the entry.
     * @returns {object} The metadata
     */

  }, {
    key: 'getOptimizedMetaData',
    value: function getOptimizedMetaData() {
      var _this2 = this;

      var optimizedMetaData = {};

      Object.keys(this.rawMetaData).forEach(function (key) {
        var valueSet = _this2.rawMetaData[key];
        optimizedMetaData[key] = _this2.optimizeMetaDataValue(valueSet);
      });

      return optimizedMetaData;
    }
  }, {
    key: 'optimizeMetaDataValue',
    value: function optimizeMetaDataValue(valueSet) {
      if (valueSet === undefined) {
        return null;
      }

      var values = [].concat(_toConsumableArray(valueSet));

      if (values.length === 1) {
        return values[0];
      }

      return values;
    }
  }, {
    key: 'getMetaData',
    value: function getMetaData(name) {
      return this.metaData[name] || null;
    }
  }, {
    key: 'bodyLines',
    get: function get() {
      if (this._bodyLines === undefined) {
        this._bodyLines = [].concat(_toConsumableArray(this.lines));

        while (!this._bodyLines[0].hasRenderableItems()) {
          this._bodyLines.shift();
        }
      }

      return this._bodyLines;
    }
  }, {
    key: 'metaData',
    get: function get() {
      if (!this.optimizedMetaData) {
        this.optimizedMetaData = this.getOptimizedMetaData();
      }

      return this.optimizedMetaData;
    }
  }]);

  return Song;
}();

var defineProperty = Object.defineProperty;
var songPrototype = Song.prototype;

_tag.META_TAGS.forEach(function (tagName) {
  defineProperty(songPrototype, tagName, {
    get: function get() {
      return this.getMetaData(tagName);
    }
  });
});

exports.default = Song;